# color / image 웹페이지 꾸미기
## 배경 꾸미기
### 배경에 그라데이션 넣기
- 그라데이션 : 두 가지 이상의 색을 이용하여 두 색을 점점 변화시켜가며 채색하는 방식. (웹사이트에서 흔히 사용되지는 않음)

참조 : https://showcases.yalco.kr/html-css/02-08/02.html
1. background 속성의 속성 값으로 linear-gradient(색1, 색2)
2. linear-gradient(각도(deg), 색1, 색2)
  - 참고 : deg -> degree
3. linear-gradient(각도, 색1, 퍼센트값, 색2)
  - 이전까지는 색상이 반반씩 나왔는데, 첫 번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣어줍니다.
4. linear-gradient(색1, 색2, 색3)
  - 참고 : linear-gradient(색1 퍼센트값1, 색2 퍼센트값2, 색3 퍼센트값3)

11_gradient.html / 11_gradient.css

- opacity : 불투명도
  transparent : 투명도

``` css
div {
  width: 200px;
  height: 200px;
  background: 
    linear-gradient(217deg, red, transparent 70%), 
    linear-gradient(127deg, lime, transparent 70%), 
    linear-gradient(336deg, blue, transparent 70%);
  }
```

## 포지셔닝
HTML로 작성한 문서(웹페이지)는 하나의 기기로만 여는 것이 아니기 때문에 상대적입니다. 따라서 요소의 위치를 잡는데 포지셔닝이 매우 중요한 역할을 합니다.
그것의 기초가 저희가 금요일에 배웠던 `<span>`과 `<div>`의 성격 차이 였습니다. 그리고 어제 display: inline / block / inline-block을 배웠었습니다.
### position 속성
참조 : https://showcases.yalco.kr/html-css/02-09/01.html

12_position.html / 12_position.css
``` html
<body>
  <div class="outer">
    <div ></div>
    <div ></div>
    <div ></div>
    <div ></div>
    <div class="yellow">
      <div class="red"></div>
    </div>
    <div ></div>
    <div ></div>
    <div ></div>
    <div ></div>
  </div>
</body>
```

``` css
div.outer {
  width: 600px;
  height: 600px;
  border: 2px solid gray;
  padding: 10px 0 0 10px;
}

.outer > div {
  width: 189px;
  height: 189px;
  margin: 0 7px 5px 0;
  background-color: gray;
  display: inline-block;
}

.outer > .yellow {
  background-color: orange;
}

.yellow > .red {
  width: 63px;
  height: 63px;
  background-color: red;
}
```

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지를 설정하는데 사용.
- `position 속성은 부모 요소의 것이지 자식에게 대물림되지 않음.` -> yellow의 position 속성이 red로 이어지지 않음을 뜻합니다.

1. static
  - position 속성의 default 값으로 top / left 등의 위치 조정을 하더라도 위치 이동 X -> HTML 구조를 따르는 것
2. relative
  - 상대적인, 이라는 의미로 위치 이동이 가능. 
  - 자신의 HTML 구조 상에서의 위치에서 이동하게 됩니다.
  - 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지가 됨
    -> 그 결과 가장 상위 div의 범위를 아예 벗어난다고 하더라도 6번 div가 5번자리로 이동하지 않음

3. absolute
  - 절대적인, 이라는 의미로 `첫 부모 요소(static이 아닌 상태로 만나는 상위 HTML 구조)`의 속성값을 이용하여 위치 이동이 가능(relative랑 다른 좌표가 필요하겠네요)
  - 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 다음 div(여기서는 6번)이 위치 이동을 하는 것을 볼 수 있습니다. 위치 이동이 일어나는 이유는 display: inline-block 때문이겠죠.
  - 그래서 .yellow가 static인 상태로 .red를 position:absolute; top:100px; left:100px;로 잡을 경우 .yellow가 `첫 부모가 아니기 때문에` 그 상위인 .outer가 첫 부묘 요소가 되고, 때문에 borderline을 가진 div 기준으로 아래로 100px, 오른쪽으로 100px 이동한 위치가 됩니다.
  - .yellow의 positoin을 relative로 잡게 되면 첫 부모 요소가 되기 때문에 노란색 div 기준으로 아래쪽으로 100px, 오른쪽으로 100px 이동한 위치로 .red가 이동하게 됩니다.

4. fixed
  - 고정된, 이라는 의미로 부모 요소가 아니라 뷰포트viewport를 기준으로 위치를 지정함. 그래서 .outer보다 더 위에 있는 브라우저 흰색 부분을 기준으로 하기 때문에 똑같이 .red를 top:100px; left:100px;을 적용하더라도 위치가 약간 위/왼쪽으로 이동하는겁니다.
  - 뷰포트에 '고정된' 위치를 사용하기 때문에 브라우저의 스크롤링에 영향을 받지 않습니다.
    - 해당 속성을 사용하게 될 경우, 특정 팝업창을 띄웠을 때 스크롤과 상관없이 한 곳에 고정시킬 때 자주 사용하는 속성입니다.

5. sticky
  - 특정 요소가 스크롤로 이동할 수 있는 공간을 top / bottom / left / right / z-index 속성값을 이용하여 지정 가능함.
  - 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링 했을 때 따라 내려오는데, 그 부분을 지나게 되면 따라오지 않는 등의 효과를 줄 때 사용함.

  - 부모 요소의 여백에 영향을 받음. 자식 요소의 위치를 고정하더라도 스크롤하면서 부모 요소의 위치를 벗어난다면, 자식 요소는 그 이상 움직이지 못함. 이상을 이유로 sticky는 부모 요소의 안쪽이 아니라 동등 / 바깥쪽 요소에 지정하는 것이 좋습니다.

position 예시 
``` html
<body>
  <div>이 요소를 화면 가운데에 배치하세요!</div>
</body>
```

``` css
body {
  margin: 0;
}

div {
  width: 300px;
  height: 80px;
  background-color: skyblue;
  /* 텍스트 중앙 위치 */
  text-align: center; /* x축 */
  line-height: 80px;  /* y축 */
  position: fixed;
  top: calc(50% - 40px);
  left: calc(50% - 150px);
  /* 특정 태그가 브라우저의 크기와 상관없이 정중앙에 위치하는 것을 담보하는 코드 */
}
```

###  z-index 속성
https://showcases.yalco.kr/html-css/02-09/02.html

- static이 아닌 모든 경우에 각 요소들간에 높이 차이를 주게 됨으로써 요소들간의 배치를 효율적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용함.
- z-index의 default 값은 auto로 설정되어 있는데, 이는 0을 의미함.
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨.
- 이상을 이유로 광고창 등의 경우 무조건 상위에 있어야하기 때문에 css 파일 확인해보시면 z-index:999; 같은 것도 구경할 수 있습니다. 

13_zindex.html / 13_zindex.css

## flex 레이아웃
- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양합니다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야했는데, 오늘날 flex가 나오면서 각종 CSS 기능을 통해 레이아웃을 설정하게 되었습니다.

### 부모에 적용하는 flex
참조 : https://showcases.yalco.kr/html-css/02-11/01.html

- 참고 : 부모에 적용하는 속성이라는 것은 부모 관련 css에 작성한다는 뜻으로 사용합니다.

참조 사이트를 기준으로 바깥쪽 div에 display:flex;를 적용했을 때와 display: inline-flex;를 적용했을 때의 p태그 위치가 바뀌는 점을 확인할 수 있습니다.

이상의 차이에서 확인할 수 있는 점
  1. display : flex;를 div에 적용했을 경우 block 성질은 그대로 유지된 상태로 flex가 적용됨
    - 그래서 p 태그가 개행된 상태로 출력
  2. display: inline-flex;를 div에 적용했을 경우 block 성질이 inline으로 바뀌게 되면서 회색 div 영역 이후의 부분에 p 태그의 텍스트가 출력됨

1. flex-direction 속성
  - 내부의 자식 요소들을 어느 축을 기준으로 정렬할 지 결정
  - default 값은 row(왼쪽부터 차례대로 정렬함) -> 자식 요소들을 row로 정렬하기 때문에 참조 사이트 기준 1, 2, 3 div가 세로로 길게 출력됨

2. justify-content
  - 메인 축에서 내부 요소를 정렬하는 방식을 결정
  - default 값은 flex-start : 왼쪽부터 내부 요소 정렬
  - center : 텍스트 중앙 정렬한 것처럼 내부 요소들을 중앙에 배치함
  - flex-end : 메인 축의 끝 부분인 오른쪽으로 내부 요소가 정렬됨. 순서는 flex-direction을 따릅니다.
  - space-between : 맨 왼쪽과 오른쪽에 하나씩 배치하고 그 사이에 나머지 요소들을 균등하게 배치
  - space-around : 각 내부 요소의 양쪽에 일정한 크기의 빈 공간을 배치 -> 1번 div 좌우에 margin처럼 보이는 애가 있고, 2번 div의 좌우에 margin이 있는 것처럼 보여서 중간 부분만 뻥 비어보입니다.
  - space-evenly : 모든 빈 공간의 크기를 고르게 지정

3. align-items : flex의 메인 축에서의 반대편 축에서(즉 flex-direction:row;라면 y축방향으로 flex-direction:column;이라면 x축 방향으로) 내부 요소를 정렬할 방식을 결정함.
  - () 내부의 내용을 토대로 flex-direction:row;라면 반대 방향인 세로 방향으로 stretch가 일어나서 세로로 긴 div이 3개 생겼다고 볼 수 있겠습니다.
  - stretch : align-items의 default값으로 이상의 설명처럼 길게 늘립니다.
  - flex-start : min-width / min-height 의 크기 그대로 정렬하는 위치를 왼쪽 상단으로부터 시작함.
  - center : 중앙 정렬
  - flex-end : 수직 축의 끝부분인 아래로 정렬

- 참고 : display:flex / flex-direction / align-items는 대부분 세트로 같이 돌아다니기 때문에 이 사이트에서 이리저리 움직여보고 css 값을 넣어보는 것도 좋은 방법입니다.

4. flex-wrap
  - 내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
  - default 값 : no-wrap
  - wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라 여러 줄일 때 사용
  - 페이지 상에서의 효과를 보면 min-width / min-height 를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div의 영역을 차지하는 것을 확인할 수 있습니다. 만약에 그게 보기 싫으면 strecch를 flex-start / center / flex-end 로 바꾸면 되죠.

5. align-content
  - align-items와 혼동이 일어나기 쉽습니다. align-items의 경우에는 flex-start / center / flex-end 를 적용했을 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위 / 중간 / 아래에서 정렬이 일어납니다. 그래서 첫째줄과 둘째줄 사이에 공백이 있습니다.

  - 반면 align-content를 사용했을 경우 1번 ~ 2번 div이 하나의 묶음으로 공백없이 정렬된 상태에서 위 / 중간 / 아래에 정렬이 일어납니다. 

6. gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(그러니까 자식 div에 margin 적용하는거랑 혼동하기가 쉽습니다.)

### 자식에 적용하는 flex
참조 : https://showcases.yalco.kr/html-css/02-11/02.html

1. flex-basis / flex-shrink
  - 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 display: flex;가 적용되어있어야 합니다. 그리고 아까 위에서 말한 것처럼 세트인 flex-direction을 적용해야합니다. 이제 설명하는 부분은 flex-direction:row;를 기준으로 합니다.

  - `부모 요소에서 flex-direction: row;`이므로 자식 요소에서의 flex-basis는 row 방향으로의 크기를 지정합니다.
  - default 값은 auto;
  - 절대값 / 상대값을 적용할 수 있습니다.

  - 만약에 자식 요소의 flex-basis를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없을겁니다.
  - 해당 경우에 사용하는 것이 flex-shrink입니다.
  - default 값 : 1
    - 전체 공간이 부족할 경우 해당 내부 요소의 크기가 컨텐츠(여기서는 주황색 div)의 width 또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값

2. flex-grow
  - default 값 : 0 - 기존의 크기를 그대로 유지함
  - 숫자의 크기에 따라 나머지 형제 요소들의 공백 크기의 곱만큼 자기가 커집니다.(커지는 방향은 flex-direction 설정값에 따름)

## 요소를 감추는 방법
1. 원래 보이던 요소를 투명하게 만드는 방법
2. 요소가 보이지 않으면서 가지고 있는 기능 자체도 날리는 방법

### CSS에서 요소를 숨기는 세 가지 방법
1. opacity 속성 활용
  - 불투명도를 뜻하며 범위는 0 ~ 1 사이의 값. 0으로 하면 불투명도 0이기 때문에 투명해집니다.
  - 해당 요소를 투명하게 만드는 것이기 때문에 기능은 존재합니다.
  - 예전에 악성 광고 사이트 같은데서 많이 쓰던 방법인데 광고 팝업을 opacity: 0;로 설정해서 클릭하면 광고 페이지로 넘어가게 하는 방식이었습니다.
2. visibility 속성 활용
  - visibility의 속성값 : visible / hidden 두가지로, hidden을 경우에 숨겨짐
  - 기능도 사라집니다.
  - 그런데 공백은 남아있어요. 보이냐 안보이냐만 지정했기 때문에 그냥 안보이는 상태에서 기능해제까지 도입되었다고 볼 수 있겠습니다.
3. display 속성 활용
  - 얘는 많은 속성값이 있었습니다. 저희가 배운 것만 해도
  - flex
  - block
  - inline
  - inline-block
  - 그런데 참조 사이트에는 div들이 일렬로 나열돼야 하기 때문에 inline-block만 나와있었습니다.
  - 그리고 none을 쓰게 되면
    - 눈에 안보이고 / 기능 삭제 되고 / 아예 없는게 되기 때문에 뒤에 있던 div가 앞으로 밀려오는 것까지 확인할 수 있습니다.

참조 : https://showcases.yalco.kr/html-css/02-10/02.html

# CSS 고급 기능(이지만 최근에는 필수인)
## 반복 및 공통되는 스타일
  - CSS를 사용하다보면 여러 페이지에서 같은 코드를 반복해서 사용하는 일이 생깁니다. CSS에서 공통적으로 사용되는 코드를 '모듈화'하여 다른 CSS 파일로 임포트하는 방법, 그리고 자주 사용하는 속성값을 변수명으로 지정하는 방법

### 다른 CSS 파일을 임포트하기
형식 :
`@import url(불러올 CSS 파일 경로)`

ch07_applied_style
01_cssimport.html / 01_cssimport.css / 00_shared.css
``` html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>css import 학습하기</title>
  <link rel="stylesheet" href="./01_cssimport.css">
</head>
<body>
  <h1>다른 CSS 파일 import 하기</h1>
  <p>
    <strong>@import</strong>를 사용하면 절대 및 상대 경로를 사용하여 <br>
    다른 CSS 파일의 내용을 불러올 수 있습니다. <br>
  </p>
  <p>
    여러 페이지에서 공통적으로 사용되는 스타일들을 특정 파일로 <br>
    분리하여 모듈화하는 것이 가능합니다.
  </p>
  <p class="sr-only">
    이 p 태그는 import된 <i>shared.css</i>의 코드가 적용됩니다.
  </p>
</body>
</html>
```

``` css
/* 00_shared.css */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rext(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* 01_cssimport.css */
/* 외부 css 파일 import */
@import url(./00_shared.css);

body {
  margin: 0;
  padding: 24px;
}
```
이상의 결과 화면을 확인했을 때 HTML 문서상에서 .sr-only 클래스명을 사용한 `<p>` 태그 내용이 보이지 않도록 숨겨지는 것을 확인할 수 있습니다. 이는 특정 문단의 내용(혹은 div일수도 있겠네요. class는 공유 가능하니까)을 감추는 설정이 담긴 shared.css 파일을 @import를 통해서 외부에서 가지고 와서 01_cssimport.css에서 사용했기 때문입니다.

이상처럼 HTML 문서를 사용할 때에 CSS를 적용하는 방식으로 
1. inline 방식
2. internal style sheet(내부 스타일 시트) 방식
2. linking style sheet(링킹 스타일 시트) 방식
으로 CSS 첫 시간에 수업을 했었는데, 이제 외부 CSS를 가지고 오는
4. @import(임포트 방식)을 들 수 있겠습니다. 상황에 따라서 선택 가능합니다.

### CSS 변수 사용하기
- 변수(variable) : 특정한 데이터에 이름을 붙이는 것을 의미함.

예를 들어서 저희는 .html을 생성할 때마다 body 태그 내에 bgcolor="5f5f5f"를 집어넣어왔습니다. 그런데, 저건 그마나 쉬우니까 그만인데 크림슨바이올렛 같은 색깔의 HEX 값을 여러분들이 외우고 있다가 3일 뒤에 물어보면 대답할 수 있을까요? 값 하나만 틀려도 다른 색이 튀어나오니까 기억하기 쉬운 이름, 즉 변수를 붙이면 사용하기가 훨씬 편리하겠습니다. -> 사실 영어권 사람들한테나 그렇고 한국인들한테는 조금 더 쉬워졌다 수준입니다.

- CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고, 그 앞에 `--` 입력해서 변수임을 표시합니다. 예를 들어서 디자이너와 프론트엔드 개발자 간에 소통하게 될 때 특정 색깔을 브랜드 메인 컬러로 설정했다면, 
`--color-main`, 그 다음 서브 컬러라면 `--color-sub1`과 같은 식으로 지정하는겁니다.
가장 작은 폰트 사이즈를 지정한다면 `--font-small`과 같은 방식이 되겠네요.

02_cssvariable.html / 02_cssvariable.css / 00_common.css

현재 상황을 고려했을 때, 00_common.css 에서 공통적으로 사용되는 변수 목록들을 설정했습니다.
디자이너들이 정해주는 폰트 크기 생상, 자간, 줄 간격 등을 모조리 변수화한 다음에 특정 프로젝트 전용으로만 쓰는 편입니다.

그리고 02_cssvariable.css에서 `@import url(.//00_common.css)`를 통해서 _해당 파일의 변수 목록을 참조할 수 있도록 import 문을 작성_하였습니다.

- var() -> 특정 CSS 변수의 데이터 값을 불러오는 함수

그런데 i태그의 class="not-good" / b태그의 class="wrong"을 적용했을 때에는 아무런 차이가 없습니다.
p태그에 공통적으로 적용한 부분만 나왔습니다.
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS 변수 사용 방법</title>
  <link rel="stylesheet" href="./02_cssvariable.css">
</head>
<body>
  <p>
    <u class="not-good">
      u 태그의 not good을 적용한 부분입니다.
    </u>
    <br>
    <u class="wrong">
      u 태그의 wrong을 적용한 부분입니다.
    </u>
  </p>
  <p>
    <i class="not-good">
      u 태그가 아닌 공통 부분의 not good을 적용한 부분입니다. 
    </i>
    <br>
    <b class="wrong">
      u 태그가 아닌 공통 부분의 not good을 적용한 부분입니다.
    </b>
  </p>
</body>
</html>
```
이상의 부분만 확인했을 때에는 i 태그와 u 태그의 class가 동일하기 때문에 동일한 css가 적용될거라고 이전까지는 생각해왔습니다.

하지만 00_common.css를 확인했을 때, 이하에서 볼 수 있듯이 u 태그에서만 --not-good / --wrong을 참조하도록 작성되어있습니다. 즉 i태그에서는 wavy underline orange;가 먹히지 않는다는 것입니다. 이런 css상에서의 위계 구조에 대해서도 알 필요가 있습니다. 
```css
/* 특정 요소에서만 사용될 수 있는 변수 목록 */
u {
  --not-good: wavy underline orange;
  --wrong: wavy underline red;
}

.wrong {
  --warn: yellow;
}

/* 
  모든 요소에서 사용될 수 있는 변수
*/
:root {
  /* 폰트 사이즈 변수 목록 */
  --font-small: 8px;
  --font-normal: 16px;
  --font-large: 24px;
  --font-x-large: 32px;
  --font-xx-large: 40px;
  --font-xxx-large: 48px;

  /* 폰트 두께 변수 목록 */
  --font-w-normal: 400;
  --font-w-bold: 600;
  --font-w-extrabold: 900;

  /* 페이지 컬러 목록 */
  --color-main: #FF4200;
  --color-sub:#865A55;
  --color-text: #49281C;
}
```
- :root의 의미
  - 어떤 요소가 특정 태그 내에서만 사용되는 것이 아니라 페이지 전체에서 광범위하게 쓰이게 될 경우 사용하는 표현. 가상 클래스를 응용하고, root는 예약어로 전체 페이지를 의미합니다. 

이상의 import문과 그 응용, 그리고 CSS 변수의 개념은 특정 페이지들의 합인 웹 서비스 상에서 공통된 요소와 특정한 요소 부분을 나누어 관리하는 것은 다른 사람과의 협업 체제에서 매우 중요한 부분 중 하나입니다.

## 벤더 프리픽스
- transition 속성
  1. -webkit-transition과 같은 방식으로 쓰이는데,
    1. -webkit : 사파리 / 크롬 / 오페라
    2. -moz : 파이어폭스
    3. -ms : 엣지 / 익스플로러
    4. -o : 구 버전 오페라

표준이 정립되는 CSS 속성들의 경우에 각 브라우저가 구현하는대로 동작합니다. 그래서 저희는 수업 시간 중에 기본앱으로 chrome으로 고정하는 시간을 가졌었구요. 즉 사용자마자 서로 다른 UX를 가지게 될 수 있다는 의미입니다.

따라서 아직 표준화되지 않았거나 최신 기능이라 사용자의 브라우저가 구버전일 가능성이 있을 때 벤더 프리픽스를 먼저 붙여서 사용하고, 공식 표준 속성은 맨마지막에 작성합니다.

왜냐면 CSS는 '순서대로' 덮어쓰기 때문에 일단 비표준으로 작성한 것이 후에 표준이 있다면 그걸로 덮어쓰기가 자동으로 이루어지기 때문입니다.

# 서체 스타일링
## 서체 및 웹 폰트(필수 / 구글 폰트 및 눈누 폰트 때문에)

### Google Fonts 도입 방법
1. chrome 구글 폰트 검색(특히 한국어로 검색하는 것이 한글 폰트가 대문에 나옵니다.)
2. 그리고 별 문제가 없다면 Noto Sans Korean을 사용하게 되는데
  - Noto : No Tofu를 의미합니다. 문자가 깨지는 빈 사각형 모양을 Tofu 라고 불렀었는데, Google에서 빡쳐서 절대 안깨지는 글씨체 만들겠다고 해서 각 국가별 Noto 시리즈가 있습니다.
  - 모든 언어를 깔끔하게 표시할 수 있는 서체.
  - 다만 이상을 이유로 너무 보편적이라서 브랜드 사용시에는 적용되지 않는 편입니다.

03_webfont.html

# JavaScript
- 갖다놓는 HTML / 꾸미는 CSS 라는 표현을 썼습니다. 그리고 특정 값의 변화 등을 시키는 역할은 JavaScript가 맡습니다. 

## 발생 배경
- 지금까지 저희가 HTML / CSS 를 학습하면서 알 수 있는 점은, 그냥 클릭했을 때 뭐가 변하는 그런 부분이 아니라, 웹 문서를 꾸미는 형태였습니다. 
- JS는 웹페이지를 _동적으로_만들기 위해 탄생한 언어입니다. 사용자가 버튼을 누르거나 특정 위치에 마우스를 올리거나 하는 등의 행위를 했을 때 상호작용을 할 수 있도록 하여 UX에 엄청난 영향을 끼친 언어라고 할 수 있습니다.

## 주요 특징
1. 인터프리터 언어 : Java와 달리 Interpreter에 해당하기 때문에 오류나기 전까지는 실행이 됩니다.
2. 동적 타입(Dynamicallt Typed) : 변수를 선언할 때 타입을 미리 지정하지 않아도 됩니다. 코드를 실행 중에 지가 적당히 보고나서 type을 결정합니다. Java가 초반에 선언해야하는 점과 매우 차이가 있습니다.
  - 이게 처음에는 편하다 좋다 하면서 쓰고 있다가 보니까, 다 작성하고 나서 테스트 할 때 돼서야 오류가 발생하는 경우가 많아서 TypeScript가 개발되기도 했습니다.
3. 객체 기반(Object-Based) : 클래스가 없이도 객체를 만들고 사용하는 것이 가능. 거의 모든 것이 객체로 취급됩니다(클래스가 없는).
4. 싱글 스레드(Single Thread) : 한 번에 하나의 작업만 순차적으로 처리합니다. 근데 비동기 처리 개념을 통해서 복잡한 작업을 효율적으로 처리하는 것은 가능합니다.

## 장점
1. 웹 브라우저의 기본 언어(language-HTML은 언어가 아니라고 했습니다.) : 별도의 설치 없이 모든 웹 브라우저에서 실행됩니다.(vs code 설치할 때와 intellij 설치할 때 생각해보시면 intellij 때는 Java 버전을 다운 받았었습니다)
2. 유연한 문법 : Java 를 배운 저희에게는 너무 자유롭다 싶겠지만 이게 초심자들에게는 장점에 해당합니다.
3. 다양한 활용분야 : 웹 브라우저 외에도 서버(Node.js), 모바일 앱(React Native), 알고리즘까지 폭넓은 분야에서 사용됩니다.
4. 생태계 : NPM(Node Package Manager)라는 패키지 저장소를 통해 수많은 오픈소스 라이브러리와 프레임워크를 활용가능합니다.
  - React는 Js의 프레임워크 중 하나입니다.

## 단점
1. 보안 : 웹브라우저에서 실행되다보니까 보안관련 설정을 많이 해줘야합니다.(저희는 SpringBoot를 통해서 해줄 예정입니다.)
2. 느린 속도 : 이건 옛날 얘기
3. 예측 불가능한 오류 : 아까 장점이었던 유연한 문법에 관련된 문제로 실제로 테스트 해보기 전까지 어떤 오류가 발생할 지 짐작하기 어려운 점이 있었습니다. - TypeScript로 보완이 가능하지만 덕분에 저희는 TypeScript도 배울 예정입니다.
4. 브라우저 호환성 문제 : 이것도 옛날 문제인데 ES6 나오고 나서는 대충 다 해결됐습니다.

```js
console.log('Hello, Javascript');
```
이상에서 보면 알 수 있듯이 얘는 "" '' 구분 없이 ''로 작성

그래서 앞으로의 수업 코드 작성 방식 :
HTML 태그 내에 있는 속성값의 경우에는 ""를 쓸거고,
JS 코드와 관련된 부분은 ''를 쓸겁니다.